module generate-safe

imports include/BufferC
imports to-c/generate
imports to-c/annotate-returns
imports runtime/types/-
imports runtime/editor/annotations 
  
rules // buffer operations

  // Write the target templates for the following rules
  // in order to implement the basic buffer primitives.
  // See generate.str for inspiration.
	
	// Allocate buffer with size zero
	gen-c-special :	
		DeclStm(Decl(Buffer(), Decl(Identifier(var))))	-> 
			$[buffer * [var];
			[var] = alloc_buf(0);]
			
	gen-c-special :	
		Buffer()	->	$[buffer *]
	
	// Creating a new buffer is reallocating the old one
	gen-c-special :
	    Assign(
            Var(Identifier(var))
          , Assign()
          , FunctionCall(Create(), [Decimal(size)]) )	->
			$[realloc_buf([var], [size]) ]
			
	gen-c-special :
		FunctionCall(Create(), es) -> $[alloc_buf([exp])]
		where
			exp := <genc><Hd> es
           
	gen-c-special :
		Null() -> $[NULL]
  		
	gen-c-special :
		String(str) -> $[[str]]
		where i := <string-length>str
			


	gen-c-special :
		Field(e, Length()) -> $[buf_length([<genc>e])]
			
	// Done in run-time
	// TODO: static check
	gen-c-special :
		Assign(ArrayField(e1, e_idx), Assign(), e2) -> $[assign_char([<genc>e1], [<genc>e_idx], [<genc>e2])]
		
	gen-c-special :
		ArrayField(e1, e2) -> $[read_element([<genc>e1], [<genc>e2])]
//		ArrayField(e1, e2) -> $[[<genc>e1]->ptr[loc]]
//		where
//			loc := $[["["][<genc>e2]["]"]]
			
	// Code gen for x = "string_literal";
	gen-c-special :
		Assign(x, Assign(), String(s)) -> $[assign_stringliteral([<genc>x], [s])]
		where
			<?Buffer()><get-type>x
			
	gen-c-special :
		FunctionCall(Print(), es) -> $[buffer_print[<genc>es]]
			
	gen-c-special :
		FunctionCall(PrintF(), es) -> $[buffer_printf[<genc>es]]
			
	gen-c-special :
		FunctionCall(Fopen(), es) -> $[bufferc_fopen[<genc>es]]
			
	gen-c-special :
		FunctionCall(Fread(), es) -> $[bufferc_fread[<genc>es]]

rules // main function

  // the main function takes 
	
	gen-c-header-special :
  	FunDef(t, Identifier("main"), params, stms) -> $[[t] [name] {
  		[c-params]
  		[c-stms]
  	}]
  	where
  		type := <genc> t
	;	name := <genc> Identifier("main")
	;	c-params := <map(genc)> params
	;	c-stms := <map(genc)> stms
    
//	gen-c-special :
//  	FunDef(t, Identifier("main"), params, stms) -> $[]
    
rules // reference counting
				
	// write more gen-c-special rules to instrument reference counting code
	
	// a typical to change is assignment
	
//	gen-c-special :
//		Assign(e1, Assign(), e2) -> $[[<genc>e1] = [<genc>e2]]

  // examples/refcount.bc contains a variety of scenarios
  
  
