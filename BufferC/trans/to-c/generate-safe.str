module generate-safe

imports include/BufferC
imports to-c/generate
imports to-c/annotate-returns
imports runtime/types/-
imports runtime/editor/annotations 
  
rules // buffer operations
	
/**************************************************
	Declaration, Allocation, Reallocation
***************************************************/	
	
	/* // deprecated: when used by itself will cause memory leaks.	
	gen-c-special :
		FunctionCall(Create(), es) -> $[alloc_buf([exp])]
		where
			exp := <genc><Hd> es
    */     
    
    // Allow create() only when declaring or assigning to prevent memory leaks
          
    gen-c-special :
       Assign(
            Var(Identifier(var))
          , Assign()
          , FunctionCall(Create(), es)
          )
		 -> $[[var] = alloc_buf([exp])]
		where
			exp := <genc><Hd> es
	
	gen-c-special :
        DeclInit(
            Buffer()
          , Decl(Identifier(var))
          , FunctionCall(Create(), es)
          )
		 -> $[buffer * [var] = alloc_buf([exp])]
		where
			exp := <genc><Hd> es
			
	//TODO: Modify the rewrite to avoid a lonely semicolomn		
	gen-c-special :
		FunctionCall(Create(), _ ) -> []
	
	// Allocate buffer with size zero
	gen-c-special :	
		DeclStm(Decl(Buffer(), Decl(Identifier(var))))	-> 
			$[buffer * [var];
			[var] = alloc_buf(0);]
			
	gen-c-special :	
		Buffer()	->	$[buffer *]
	
	// Creating a new buffer is reallocating the old one
	gen-c-special :
	    Assign(
            Var(Identifier(var))
          , Assign()
          , FunctionCall(Create(), [Decimal(size)]) )	->
			$[realloc_buf([var], [size]) ]
/*

*/	

	
	gen-c-special :
		Null() -> $[NULL]
  		
	gen-c-special :
		String(str) -> $[[str]]
	//	where i := <string-length>str
			
	gen-c-special :
		Field(e, Length()) -> $[buf_length([<genc>e])]
			
	// Done in run-time
	// TODO: static check
	gen-c-special :
		Assign(ArrayField(e1, e_idx), Assign(), e2) -> $[assign_char([<genc>e1], [<genc>e_idx], [<genc>e2])]
		
	gen-c-special :
		ArrayField(e1, e2) -> $[read_element([<genc>e1], [<genc>e2])]
//		ArrayField(e1, e2) -> $[[<genc>e1]->ptr[loc]]
//		where
//			loc := $[["["][<genc>e2]["]"]]
			
	// Code gen for x = "string_literal";
	gen-c-special :
		Assign(x, Assign(), String(s)) -> $[assign_stringliteral([<genc>x], [s], [len])]
		where
			<?Buffer()><get-type>x
		;	len := <subt>(<string-length>s,2)
			
	// a = b	//TODO: Should we free a before doing the assignment?
	gen-c-special :
		Assign(Var(Identifier(var1)), Assign(), Var(Identifier(var2))) -> 
		$[ free([var1]);
		[var1] = copy([var2])]
		where
			<?Buffer()><get-type>var1
		;	<?Buffer()><get-type>var2
	
/**************************************************
	Printing
***************************************************/	

	// deprecated, print() should only print one bufferc string
	//gen-c-special :
	//	FunctionCall(Print(), es) -> $[bufferc_print([<mapsep(genc|", ")>es])]
	
	gen-c-special :
		FunctionCall(Print(), es) -> $[bufferc_print([exp])]
		where
		exp := <genc><Hd>es
	
	is-it-buffer:
		var -> $[var->ptr]
		where
		<?Buffer()><get-type>var
	
	// TODO: Must fix this to use the proper buffer pointer 				
	gen-c-special :
		FunctionCall(PrintF(), es) -> $[printf([<mapsep(genc|", ")>es])]
			
	gen-c-special :
		FunctionCall(Fopen(), es) -> $[bufferc_fopen[<genc>es]]
			
	gen-c-special :
		FunctionCall(Fread(), es) -> $[bufferc_fread[<genc>es]]

rules // main function

  // the main function takes 
	
	gen-c-header-special :
  	FunDef(t, Identifier("main"), params, stms) -> $[[t] [name] {
  		[c-params]
  		[c-stms]
  	}]
  	where
  		type := <genc> t
	;	name := <genc> Identifier("main")
	;	c-params := <map(genc)> params
	;	c-stms := <map(genc)> stms
    
//	gen-c-special :
//  	FunDef(t, Identifier("main"), params, stms) -> $[]
    
rules // reference counting
				
	// write more gen-c-special rules to instrument reference counting code
	
	// a typical to change is assignment
	
//	gen-c-special :
//		Assign(e1, Assign(), e2) -> $[[<genc>e1] = [<genc>e2]]

  // examples/refcount.bc contains a variety of scenarios
  
  
